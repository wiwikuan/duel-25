<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã€Œæ±ºé¬¥ 25ã€ç´™ç‰Œå°æˆ°éŠæˆ² by Wiwi.Blog</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .game-container {
            max-width: 400px;
            margin: 0 auto;
            padding: 10px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            border-radius: 8px;
            background-color: white;
        }
        
        .game-title {
            text-align: left;
            margin: 0 0 3px 0;
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .game-rules {
            text-align: left;
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
        
        .hp-display {
            display: flex;
            justify-content: left;
            align-items: left;
            gap: 20px;
            margin-top: 5px;
            margin-bottom: 3px;
            font-size: 1rem;
            font-weight: bold;
        }
        
        .player-hp {
            color: #2e7d32;
        }
        
        .computer-hp {
            color: #c62828;
        }
        
        .hand-title {
            font-size: 1rem;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .card-container {
            display: flex;
            gap: 10px;
            justify-content: left;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .card {
            border: 1px solid #777;
            border-radius: 3px;
            padding: 0px 7px;
            cursor: pointer;
            font-size: 1rem;
            min-width: 35px;
            text-align: center;
            transition: all 0.2s;
            background-color: white;
        }
        
        .card:hover {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transform: translateY(-2px);
        }
        
        .battle-log {
            min-height: 7rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-y: auto;
            max-height: 7rem;
            background-color: #fafafa;
        }
        
        .game-over {
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            color: #d32f2f;
            margin: 10px 0;
        }
        
        .restart-button {
            display: block;
            margin: 10px auto 0;
            padding: 8px 16px;
            background-color: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .restart-button:hover {
            background-color: #1565c0;
        }
        
        hr {
            margin: 0;
            height: 1px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h2 class="game-title">ã€Œæ±ºé¬¥ 25ã€ç´™ç‰Œå°æˆ°éŠæˆ² v2.1</h2>
        
        <div class="game-rules">by <a href="https://wiwi.blog">Wiwi Kuan</a> | <a href="https://wiwi.blog/blog/simple-card-battle-game">æ€éº¼ç©ï¼Ÿ</a><br />â™ ï¸â™£ï¸ æ”»æ“Š |  â™¦ï¸ åæ“Š |  â™¥ï¸ å›è¡€</div>

        <hr />
        
        <div class="hp-display">
            <span class="player-hp">ç©å®¶ï¼š<span id="playerHp">25</span> HP</span>
            <span class="computer-hp">é›»è…¦ï¼š<span id="computerHp">25</span> HP</span>
        </div>
        
        <div>
            <div class="hand-title">ä½ çš„æ‰‹ç‰Œï¼ˆé»æ“Šå‡ºç‰Œï¼‰:</div>
            <div class="card-container" id="playerHand"></div>
        </div>

        <div>
            <div style="margin-bottom: 5px;">
                <span style="font-weight: bold; font-size: 0.9rem;" id="roundDisplay">æº–å‚™é–‹å§‹</span>
            </div>
            <div class="battle-log" id="battleResult">é»æ“Šæ‰‹ç‰Œå‡ºç‰Œé–‹å§‹å°æˆ°ï¼</div>
            <div style="text-align: center; margin-top: 8px;">
                <button id="historyButton"
                    style="padding: 4px 12px; font-size: 0.8rem; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; cursor: pointer;"
                    onclick="toggleHistory()">é¡¯ç¤ºæ­·å²</button>
            </div>
            <div id="historyPanel"
                style="display: none; margin-top: 8px; max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
                <div style="padding: 8px; font-size: 0.8rem;" id="historyContent">å°šç„¡æ­·å²è¨˜éŒ„</div>
            </div>
        </div>

        <div class="game-over" id="gameOverMessage"></div>
        
        <button class="restart-button" id="restartButton" style="display: none;" onclick="initGame()">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        // éŠæˆ²ç‹€æ…‹
        let gameState = {
            playerHp: 25,
            computerHp: 25,
            playerHand: [],
            computerHand: [],
            deck: [],
            gameEnded: false,
            battleResult: 'é»æ“Šæ‰‹ç‰Œå‡ºç‰Œé–‹å§‹å°æˆ°ï¼',
            gameOverMessage: '',
            currentRound: 0,
            battleHistory: []
        };

        // å»ºç«‹ä¸€å‰¯å®Œæ•´çš„æ’²å…‹ç‰Œ
        function createDeck() {
            const suits = ['â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const newDeck = [];
            
            for (let suit of suits) {
                for (let value of values) {
                    newDeck.push({ suit, value });
                }
            }
            
            return newDeck;
        }

        // æ´—ç‰Œ
        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // å–å¾—ç‰Œçš„é»æ•¸å€¼
        function getCardValue(card) {
            if (card.value === 'A') return 1;
            if (card.value === 'J') return 11;
            if (card.value === 'Q') return 12;
            if (card.value === 'K') return 13;
            return parseInt(card.value);
        }

        // åˆ¤æ–·ç‰Œçš„é¡å‹
        function getCardType(card) {
            if (card.suit === 'â™ ï¸' || card.suit === 'â™£ï¸') return 'attack';
            if (card.suit === 'â™¦ï¸') return 'counter';
            if (card.suit === 'â™¥ï¸') return 'heal';
        }

        // æ ¼å¼åŒ–é¡¯ç¤ºç‰Œ
        function formatCard(card) {
            return `${card.value}${card.suit}`;
        }

        // è™•ç†æ”»æ“Šå‚·å®³
        function processAttack(attackCard, targetHp) {
            const damage = getCardValue(attackCard);
            return Math.max(0, targetHp - damage);
        }

        // è™•ç†å›è¡€
        function processHeal(healCard, currentHp) {
            const healAmount = getCardValue(healCard);
            return Math.min(25, currentHp + healAmount);
        }

        // è™•ç†ä¸€å›åˆçš„æˆ°é¬¥
        function processBattle(playerCard, computerCard) {
            gameState.currentRound++;
            let battleLog = [];
            // battleLog.push(`ç¬¬ ${gameState.currentRound} å›åˆ`);
            battleLog.push(`ç©å®¶å‡ºç‰Œï¼š${formatCard(playerCard)}`);
            battleLog.push(`é›»è…¦å‡ºç‰Œï¼š${formatCard(computerCard)}`);
            
            let newPlayerHp = gameState.playerHp;
            let newComputerHp = gameState.computerHp;
            
            const playerCardType = getCardType(playerCard);
            const computerCardType = getCardType(computerCard);
            
            // ç¬¬ä¸€éšæ®µï¼šè™•ç†æ”»æ“Šå’Œåæ“Š
            if (playerCardType === 'attack' && computerCardType === 'attack') {
                // é›™æ–¹äº’ç›¸æ”»æ“Š
                newComputerHp = processAttack(playerCard, newComputerHp);
                newPlayerHp = processAttack(computerCard, newPlayerHp);
                battleLog.push(`é›™æ–¹äº’ç›¸æ”»æ“Šï¼`);
                battleLog.push(`ç©å®¶å—å‚· ${getCardValue(computerCard)}ï¼Œé›»è…¦å—å‚· ${getCardValue(playerCard)}`);
            } else {
                // ç©å®¶æ”»æ“Š
                if (playerCardType === 'attack') {
                    if (computerCardType === 'counter') {
                        newPlayerHp = processAttack(computerCard, newPlayerHp);
                        battleLog.push(`ç©å®¶æ”»æ“Šè¢«åæ“Šï¼å—åˆ° ${getCardValue(computerCard)} åæ“Šå‚·å®³`);
                    } else {
                        newComputerHp = processAttack(playerCard, newComputerHp);
                        battleLog.push(`ç©å®¶æ”»æ“Šï¼é›»è…¦å—åˆ° ${getCardValue(playerCard)} å‚·å®³`);
                    }
                }
                
                // é›»è…¦æ”»æ“Š
                if (computerCardType === 'attack') {
                    if (playerCardType === 'counter') {
                        newComputerHp = processAttack(playerCard, newComputerHp);
                        battleLog.push(`é›»è…¦æ”»æ“Šè¢«åæ“Šï¼å—åˆ° ${getCardValue(playerCard)} åæ“Šå‚·å®³`);
                    } else {
                        newPlayerHp = processAttack(computerCard, newPlayerHp);
                        battleLog.push(`é›»è…¦æ”»æ“Šï¼ç©å®¶å—åˆ° ${getCardValue(computerCard)} å‚·å®³`);
                    }
                }
            }
            
            // æª¢æŸ¥è‡´å‘½å‚·å®³
            if (newPlayerHp <= 0 || newComputerHp <= 0) {
                gameState.playerHp = newPlayerHp;
                gameState.computerHp = newComputerHp;
                battleLog.push('è‡´å‘½å‚·å®³ï¼éŠæˆ²çµæŸï¼');

                // å„²å­˜æˆ°é¬¥è¨˜éŒ„åˆ°æ­·å²ï¼ˆè‡´å‘½å‚·å®³æƒ…æ³ï¼‰
                const roundRecord = {
                    round: gameState.currentRound,
                    playerCard: formatCard(playerCard),
                    computerCard: formatCard(computerCard),
                    log: battleLog.slice(1), // ä¸åŒ…å«å›åˆæ¨™é¡Œ
                    playerHpBefore: gameState.playerHp,
                    computerHpBefore: gameState.computerHp,
                    playerHpAfter: newPlayerHp,
                    computerHpAfter: newComputerHp
                };
                gameState.battleHistory.push(roundRecord);

                gameState.battleResult = battleLog.join('<br>');
                checkGameEnd(newPlayerHp, newComputerHp);
                updateDisplay();
                return;
            }
            
            // è™•ç†ç„¡æ•ˆåæ“Š
            if (playerCardType === 'counter' && computerCardType !== 'attack') {
                battleLog.push(`ç©å®¶åæ“Šç„¡æ•ˆï¼ˆå°æ–¹æ²’æœ‰æ”»æ“Šï¼‰`);
            }
            if (computerCardType === 'counter' && playerCardType !== 'attack') {
                battleLog.push(`é›»è…¦åæ“Šç„¡æ•ˆï¼ˆå°æ–¹æ²’æœ‰æ”»æ“Šï¼‰`);
            }
            
            // æ›´æ–°ç”Ÿå‘½å€¼
            gameState.playerHp = newPlayerHp;
            gameState.computerHp = newComputerHp;
            
            // ç¬¬äºŒéšæ®µï¼šè™•ç†å›è¡€
            if (playerCardType === 'heal') {
                const originalPlayerHp = newPlayerHp;
                newPlayerHp = processHeal(playerCard, newPlayerHp);
                gameState.playerHp = newPlayerHp;
                battleLog.push(`ç©å®¶å›è¡€ ${newPlayerHp - originalPlayerHp} é»`);
            }
            
            if (computerCardType === 'heal') {
                const originalComputerHp = newComputerHp;
                newComputerHp = processHeal(computerCard, newComputerHp);
                gameState.computerHp = newComputerHp;
                battleLog.push(`é›»è…¦å›è¡€ ${newComputerHp - originalComputerHp} é»`);
            }

            // å„²å­˜æˆ°é¬¥è¨˜éŒ„åˆ°æ­·å²
            const roundRecord = {
                round: gameState.currentRound,
                playerCard: formatCard(playerCard),
                computerCard: formatCard(computerCard),
                log: battleLog.slice(1), // ä¸åŒ…å«å›åˆæ¨™é¡Œ
                playerHpBefore: gameState.playerHp,
                computerHpBefore: gameState.computerHp,
                playerHpAfter: newPlayerHp,
                computerHpAfter: newComputerHp
            };
            gameState.battleHistory.push(roundRecord);

            gameState.battleResult = battleLog.join('<br>');
        }

        // æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
        function checkGameEnd(currentPlayerHp = gameState.playerHp, currentComputerHp = gameState.computerHp) {
            let gameOverMsg = '';
            
            if (currentPlayerHp <= 0 && currentComputerHp <= 0) {
                gameOverMsg = 'å¹³æ‰‹ï¼';
            } else if (currentPlayerHp <= 0) {
                gameOverMsg = 'é›»è…¦å‹åˆ©ï¼';
            } else if (currentComputerHp <= 0) {
                gameOverMsg = 'ç©å®¶å‹åˆ©ï¼';
            }
            
            if (gameOverMsg) {
                gameState.gameEnded = true;
                gameState.gameOverMessage = gameOverMsg;
                return true;
            }
            
            return false;
        }

        // ç‰Œå †ç”¨å®Œçš„ Game Over
        function noMoreCardsGameOver() {
            gameState.gameEnded = true;
            gameState.gameOverMessage = 'ç‰Œå †ç”¨å®Œï¼Œå¹³æ‰‹ï¼';
            return true;
        }

        // è£œç‰Œ
        function drawCards(currentPlayerHand, currentComputerHand, currentDeck) {
            const newPlayerHand = [...currentPlayerHand];
            const newComputerHand = [...currentComputerHand];
            const newDeck = [...currentDeck];
            
            // ç©å®¶è£œç‰Œ
            while (newPlayerHand.length < 5 && newDeck.length > 0) {
                newPlayerHand.push(newDeck.pop());
            }
            
            // é›»è…¦è£œç‰Œ
            while (newComputerHand.length < 5 && newDeck.length > 0) {
                newComputerHand.push(newDeck.pop());
            }
            
            return { newPlayerHand, newComputerHand, newDeck };
        }

        // MCTS AI é¸ç‰Œ
        function mctsChooseCard(gameStateForAI) {
            const { computerHand, playerHp, computerHp } = gameStateForAI;
            let bestCard = 0;
            let bestWinRate = -1;
            let debugInfo = [];
            
            // å°æ¯å¼µæ‰‹ç‰Œæ¨¡æ“¬ 5000 æ¬¡å°å±€
            for (let i = 0; i < computerHand.length; i++) {
                let wins = 0;
                for (let sim = 0; sim < 5000; sim++) {
                    if (simulateGame(gameStateForAI, i)) wins++;
                }
                const winRate = wins / 5000;
                const card = computerHand[i];
                debugInfo.push(`${formatCard(card)}: ${(winRate * 100).toFixed(1)}% å‹ç‡`);
                
                if (winRate > bestWinRate) {
                    bestWinRate = winRate;
                    bestCard = i;
                }
            }
            
            // è¼¸å‡º debug è³‡è¨Š
            console.log(`ğŸ¤– MCTS æ€è€ƒä¸­... (è¡€é‡ ${computerHp}/${playerHp})`);
            console.log(debugInfo.join(' | '));
            console.log(`â†’ é¸æ“‡ ${formatCard(computerHand[bestCard])} (${(bestWinRate * 100).toFixed(1)}% å‹ç‡)`);
            
            return bestCard;
        }

        // æ¨¡æ“¬å®Œæ•´å°å±€ï¼ˆé›»è…¦è¦–è§’ï¼Œå›å‚³é›»è…¦æ˜¯å¦ç²å‹ï¼‰
        function simulateGame(gameStateForSim, computerCardIndex) {
            let simPlayerHp = gameStateForSim.playerHp;
            let simComputerHp = gameStateForSim.computerHp;
            let simDeck = [...gameStateForSim.deck];
            let simPlayerHand = [...gameStateForSim.playerHand];
            let simComputerHand = [...gameStateForSim.computerHand];
            
            // ç¬¬ä¸€å›åˆï¼šé›»è…¦å‡ºæŒ‡å®šç‰Œï¼Œç©å®¶éš¨æ©Ÿå‡ºç‰Œ
            const computerCard = simComputerHand.splice(computerCardIndex, 1)[0];
            const playerCard = simPlayerHand.splice(Math.floor(Math.random() * simPlayerHand.length), 1)[0];
            
            const result = simulateBattle(playerCard, computerCard, simPlayerHp, simComputerHp);
            simPlayerHp = result.playerHp;
            simComputerHp = result.computerHp;
            
            if (simPlayerHp <= 0) return true;
            if (simComputerHp <= 0) return false;
            
            // è£œç‰Œä¸¦ç¹¼çºŒéš¨æ©Ÿå°å±€
            while (simPlayerHand.length < 5 && simDeck.length > 0) simPlayerHand.push(simDeck.pop());
            while (simComputerHand.length < 5 && simDeck.length > 0) simComputerHand.push(simDeck.pop());
            
            // å¾ŒçºŒå›åˆéƒ½éš¨æ©Ÿå‡ºç‰Œ
            for (let turn = 0; turn < 20 && simPlayerHp > 0 && simComputerHp > 0 && simDeck.length > 0; turn++) {
                if (simPlayerHand.length === 0 || simComputerHand.length === 0) break;
                
                const pCard = simPlayerHand.splice(Math.floor(Math.random() * simPlayerHand.length), 1)[0];
                const cCard = simComputerHand.splice(Math.floor(Math.random() * simComputerHand.length), 1)[0];
                
                const battleResult = simulateBattle(pCard, cCard, simPlayerHp, simComputerHp);
                simPlayerHp = battleResult.playerHp;
                simComputerHp = battleResult.computerHp;
                
                if (simPlayerHp <= 0) return true;
                if (simComputerHp <= 0) return false;
                
                while (simPlayerHand.length < 5 && simDeck.length > 0) simPlayerHand.push(simDeck.pop());
                while (simComputerHand.length < 5 && simDeck.length > 0) simComputerHand.push(simDeck.pop());
            }
            
            return simComputerHp > simPlayerHp;
        }

        // å¿«é€Ÿæˆ°é¬¥æ¨¡æ“¬
        function simulateBattle(playerCard, computerCard, playerHp, computerHp) {
            let newPlayerHp = playerHp;
            let newComputerHp = computerHp;
            
            const pType = getCardType(playerCard);
            const cType = getCardType(computerCard);
            
            // æ”»æ“Šå’Œåæ“Šé‚è¼¯
            if (pType === 'attack' && cType === 'attack') {
                newPlayerHp = Math.max(0, newPlayerHp - getCardValue(computerCard));
                newComputerHp = Math.max(0, newComputerHp - getCardValue(playerCard));
            } else {
                if (pType === 'attack') {
                    if (cType === 'counter') {
                        newPlayerHp = Math.max(0, newPlayerHp - getCardValue(computerCard));
                    } else {
                        newComputerHp = Math.max(0, newComputerHp - getCardValue(playerCard));
                    }
                }
                if (cType === 'attack') {
                    if (pType === 'counter') {
                        newComputerHp = Math.max(0, newComputerHp - getCardValue(playerCard));
                    } else {
                        newPlayerHp = Math.max(0, newPlayerHp - getCardValue(computerCard));
                    }
                }
            }
            
            // å¦‚æœæœ‰è‡´å‘½å‚·å®³å°±ä¸å›è¡€äº†
            if (newPlayerHp <= 0 || newComputerHp <= 0) {
                return { playerHp: newPlayerHp, computerHp: newComputerHp };
            }
            
            // å›è¡€
            if (pType === 'heal') newPlayerHp = Math.min(25, newPlayerHp + getCardValue(playerCard));
            if (cType === 'heal') newComputerHp = Math.min(25, newComputerHp + getCardValue(computerCard));
            
            return { playerHp: newPlayerHp, computerHp: newComputerHp };
        }

        // ç©å®¶å‡ºç‰Œ
        function playCard(cardIndex) {
            if (gameState.gameEnded) return;
            
            // ç©å®¶å‡ºç‰Œ
            const newPlayerHand = [...gameState.playerHand];
            const playerCard = newPlayerHand.splice(cardIndex, 1)[0];

            // é›»è…¦ç”¨ MCTS é¸ç‰Œ
            const newComputerHand = [...gameState.computerHand];
            const gameStateForAI = {
                playerHp: gameState.playerHp, 
                computerHp: gameState.computerHp, 
                deck: gameState.deck,
                playerHand: newPlayerHand,
                computerHand: newComputerHand
            };
            const computerCardIndex = mctsChooseCard(gameStateForAI);
            const computerCard = newComputerHand.splice(computerCardIndex, 1)[0];
            
            // è™•ç†æˆ°é¬¥
            processBattle(playerCard, computerCard);
            
            // è£œç‰Œ
            const { newPlayerHand: finalPlayerHand, newComputerHand: finalComputerHand, newDeck } = drawCards(newPlayerHand, newComputerHand, gameState.deck);
            
            gameState.playerHand = finalPlayerHand;
            gameState.computerHand = finalComputerHand;
            gameState.deck = newDeck;
            
            if (newDeck.length < 2 && !gameState.gameEnded) { // ç‰Œå †ç”¨å®Œï¼Œè€Œä¸”æ²’æœ‰äººæ­»æ‰å—ï¼Ÿ
                noMoreCardsGameOver(); 
            }

            updateDisplay();
        }

        // åˆ‡æ›æ­·å²é¢æ¿é¡¯ç¤º
        function toggleHistory() {
            const historyPanel = document.getElementById('historyPanel');
            const historyButton = document.getElementById('historyButton');

            if (historyPanel.style.display === 'none') {
                updateHistoryDisplay();
                historyPanel.style.display = 'block';
                historyButton.textContent = 'éš±è—æ­·å²';
            } else {
                historyPanel.style.display = 'none';
                historyButton.textContent = 'é¡¯ç¤ºæ­·å²';
            }
        }

        // æ›´æ–°æ­·å²è¨˜éŒ„é¡¯ç¤º
        function updateHistoryDisplay() {
            const historyContent = document.getElementById('historyContent');

            if (gameState.battleHistory.length === 0) {
                historyContent.innerHTML = 'å°šç„¡æ­·å²è¨˜éŒ„';
                return;
            }

            let historyHtml = '';
            gameState.battleHistory.forEach((record, index) => {
                const isLatest = index === gameState.battleHistory.length - 1;
                const bgColor = isLatest ? '#e3f2fd' : '#f9f9f9';

                historyHtml += `
                    <div style="padding: 6px; margin-bottom: 4px; background: ${bgColor}; border-radius: 3px; cursor: pointer;" onclick="showRoundDetail(${index})">
                        <strong>ç¬¬ ${record.round} å›åˆ</strong> - ${record.playerCard} vs ${record.computerCard}
                        <div style="font-size: 0.75rem; color: #666;">
                            ç©å®¶: ${record.playerHpBefore}â†’${record.playerHpAfter} HP | é›»è…¦: ${record.computerHpBefore}â†’${record.computerHpAfter} HP
                        </div>
                    </div>
                `;
            });

            historyContent.innerHTML = historyHtml;

            // è‡ªå‹•æ»¾å‹•åˆ°æœ€ä¸‹é¢é¡¯ç¤ºæœ€æ–°æˆ°é¬¥
            const historyPanel = document.getElementById('historyPanel');
            setTimeout(() => {
                historyPanel.scrollTop = historyPanel.scrollHeight;
            }, 0);
        }

        // é¡¯ç¤ºç‰¹å®šå›åˆçš„è©³ç´°è¨˜éŒ„
        function showRoundDetail(recordIndex) {
            const record = gameState.battleHistory[recordIndex];
            const battleResult = document.getElementById('battleResult');

            let detailLog = [`ç¬¬ ${record.round} å›åˆ`];
            detailLog = detailLog.concat(record.log);

            battleResult.innerHTML = detailLog.join('<br>');

            // æ›´æ–°å›åˆé¡¯ç¤º
            document.getElementById('roundDisplay').textContent = `æŸ¥çœ‹ç¬¬ ${record.round} å›åˆ`;
        }

        // æ›´æ–°é¡¯ç¤º
        function updateDisplay() {
            document.getElementById('playerHp').textContent = gameState.playerHp;
            document.getElementById('computerHp').textContent = gameState.computerHp;
            document.getElementById('battleResult').innerHTML = gameState.battleResult;
            document.getElementById('gameOverMessage').textContent = gameState.gameOverMessage;

            // æ›´æ–°å›åˆé¡¯ç¤º
            if (gameState.currentRound === 0) {
                document.getElementById('roundDisplay').textContent = 'æº–å‚™é–‹å§‹';
            } else {
                document.getElementById('roundDisplay').textContent = `ç¬¬ ${gameState.currentRound} å›åˆ`;
            }

            // å¦‚æœæ­·å²é¢æ¿æ˜¯é–‹å•Ÿçš„ï¼Œè‡ªå‹•æ›´æ–°æ­·å²è¨˜éŒ„
            const historyPanel = document.getElementById('historyPanel');
            if (historyPanel.style.display === 'block') {
                updateHistoryDisplay();
            }

            // æ›´æ–°æ‰‹ç‰Œé¡¯ç¤º
            const playerHandDiv = document.getElementById('playerHand');
            playerHandDiv.innerHTML = '';
            gameState.playerHand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.textContent = formatCard(card);
                cardDiv.onclick = () => playCard(index);
                playerHandDiv.appendChild(cardDiv);
            });

            // é¡¯ç¤º/éš±è—é‡æ–°é–‹å§‹æŒ‰éˆ•
            const restartButton = document.getElementById('restartButton');
            if (gameState.gameEnded) {
                restartButton.style.display = 'block';
            } else {
                restartButton.style.display = 'none';
            }
        }

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            // é‡ç½®éŠæˆ²ç‹€æ…‹
            gameState.playerHp = 25;
            gameState.computerHp = 25;
            gameState.gameEnded = false;
            gameState.gameOverMessage = '';
            gameState.battleResult = 'é»æ“Šæ‰‹ç‰Œå‡ºç‰Œé–‹å§‹å°æˆ°ï¼';
            gameState.currentRound = 0;
            gameState.battleHistory = [];

            // éš±è—æ­·å²é¢æ¿
            document.getElementById('historyPanel').style.display = 'block';
            document.getElementById('historyButton').textContent = 'éš±è—æ­·å²';

            // å»ºç«‹ä¸¦æ´—ç‰Œ
            const newDeck = shuffleDeck(createDeck());
            
            // ç™¼åˆå§‹æ‰‹ç‰Œ
            const initialPlayerHand = [];
            const initialComputerHand = [];
            
            for (let i = 0; i < 5; i++) {
                initialPlayerHand.push(newDeck.pop());
                initialComputerHand.push(newDeck.pop());
            }
            
            gameState.playerHand = initialPlayerHand;
            gameState.computerHand = initialComputerHand;
            gameState.deck = newDeck;
            
            updateDisplay();
        }

        // é é¢åŠ è¼‰æ™‚åˆå§‹åŒ–éŠæˆ²
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>
